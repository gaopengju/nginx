#+TITLE: NGINX代码导读
#+AUTHOR: sqlfocus


* 入口
*文件* main():~/src/core/nginx.c

* 信号处理
*函数入口* =ngx_signal_process():~/src/os/unix/ngx_process.c=

对应命令行参数-s

* 时间缓存
*函数* ~ngx_time_init()~ : =~/src/core/ngx_times.c=

nginx中的时间以秒为粒度，被缓存起来，并形成丰富的字符串格式；此设计使得
少更新多读取的时间操作尤其高效。

缓存时间设定了定量的槽位，构成缓存循环队列；以免某些请求的处理时间大于s
的粒度，造成紊乱。

* DONE 定时器管理
  CLOSED: [2016-10-26 Wed 14:03]
事件超时意味着等待的事件没有在指定的时间内到达，nginx有必要对这些可能发生
超时的事件进行统一管理，并在事件发生超时时做出相应的处理，比如回收资源、
返回错误等。

超时管理需要解决两个问题，第一，超时事件对象如何组织，nginx采用红黑树；第
二，超时检测。

nginx采用两种方式检测超时，第一，定时检测机制，通过设定定时器，每隔一段时
间对红黑树扫瞄一次；第二，计算最快发生的事件需要等待的时间，在系统调用函数
epoll_wait()中，设定此超时时限，以便尽快儿检测。

定时检测机制通过配置指令"timer_resolution 100ms;"指定。

  #+BEGIN_EXAMPLE
  -ngx_worker_process_cycle()         worker进程入口
    -ngx_worker_process_init()        worker进程初始化
      -ngx_module_t->init_process()
      =ngx_event_process_init()      
        -ngx_event_timer_init()       红黑树初始化入口，ngx_event_timer.c
    -for(;;)
      -ngx_process_events_and_timers()
        -ngx_event_find_timer()       计算最近事件的超时时间间隔
        -ngx_event_expire_timers()    处理超时事件

  添加超时事件
  -ngx_add_timer()                    入口，ngx_event.h
    -ngx_event_add_timer()            ngx_event_timer.h
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  定时检测机制
     1) 通过指令"timer_resolution 100ms;"设置后，在初始化时会启动系统定时器，
        以定期向进程发送信号；
     2) 定时器信号SIGALRM被捕获后，设置全局变量，从而触发epoll_wait()系统调
        用返回，并更新内部时钟；
     3) worker进程处理请求间歇，检测到内部时钟变更，则触发超时事件树扫瞄
  从以上描述可知，虽然信号保证了触发粒度，但worker进程只在请求处理返回后才能
  处理超时事件，因此无法保证及时处理。考虑到nginx的请求处理速度，这不是什么
  问题。

  从流程中也可看出，采用方式二可能带来更高精度。

  -ngx_worker_process_cycle()
    -ngx_worker_process_init()
      -ngx_module_t->init_process()
      =ngx_event_process_init()  
        -ngx_event_timer_init()
        -setitimer()                  设定定时器，以定时触发ngx_timer_signal_handler()
                                      此函数设置ngx_event_timer_alarm变量
    -for(;;)
      -ngx_process_events_and_timers()
        -根据超时事件类型，设置不同标志
          -定时扫瞄不设置标识
          -非定时扫瞄设置标识NGX_UPDATE_TIME
        -ngx_process_events()
        =ngx_epoll_process_events()
          -epoll_wait()
          -ngx_time_update()          ngx_event_timer_alarm=1 或 设置了NGX_UPDATE_TIME标识
        -计算运行时间
          -只有运行了ngx_time_update()后，才有值
        -ngx_event_expire_timers()    处理超时事件，运行时间不等于0时调用
  #+END_EXAMPLE

* 插口继承
*函数* =ngx_add_inherited_sockets()= :~/src/core/nginx.c

启动nginx时，可通过环境变量NGINX继承已有的socket插口

* 进程间通信
一般情况下，nginx以多进程模型运作，这些进程间通信有多种方式，如共享内存、匿名
管道等。

** 匿名管道
采用socketpair()创建的匿名管道，对于Linux下具有亲缘关系的进程之间的通信是不错
的解决方案。

进程信息及管道句柄等记录在全局数据结构，ngx_processes[]，此结构在进程被fork出
的过程中初始化；并在进程退出后更新。

  #+BEGIN_EXAMPLE
  ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];     /* ngx_process.c */

  typedef struct {
    ngx_pid_t           pid;              /* 进程ID */
    int                 status;           /* waitpid()的返回值 */
    ngx_socket_t        channel[2];       /* 进程间通信的管道
                                             worker[1] -- master[0]
                                             worker[0] -- other worker[1] */

    ngx_spawn_proc_pt   proc;             /* 进程入口函数 */
    void               *data;             /* 进程私有信息; 对于worker为启动index，即0~ngx_core_conf_t->worker_processes */
    char               *name;             /* 进程名 */
    
    unsigned            respawn:1;        /* 进程退出后是否自动重启 */
    unsigned            just_spawn:1;
    unsigned            detached:1;       /* 脱离跟踪，不和主进程及其他进程建通信管道 */
    unsigned            exiting:1;
    unsigned            exited:1;         /* 0/1, 是否已经退出 */
  } ngx_process_t;
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  -main()
    -ngx_master_process_cycle()
      1-ngx_start_worker_processes()
        -ngx_spawn_process()
          -socketpair()
          -fork()
          -----------------------------子进程----------------------------
          -ngx_worker_process_cycle()            worker进程入口
            -ngx_worker_process_init()
              -ngx_add_channel_event()           监听其他进程的管道描述符，处
                                                 理句柄ngx_channel_handler()
            -for(;;)
          -----------------------------父进程----------------------------
          -记录PID/管道描述符等到ngx_processes[]
        -ngx_pass_open_channel()                 利用消息通知其他进程，有新进程加入
          -ngx_write_channel()
            -sendmsg()                           利用了进程间描述符传递
      1-for(;;)                                  信号处理
        -退出相关信号设计管道信息变更            上半阶段处理ngx_signal_handler()
                                                 后半阶段处理在此循环中
  #+END_EXAMPLE

** 共享内存
共享内存是Linux下进程间通信的最有效方式之一，nginx提供了统一接口以方便模块儿
使用共享内存。

  #+BEGIN_EXAMPLE
  配置文件示例
  http {
     #为限速模块儿所用，ngx_http_limit_req_module
     limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
     ...
  }

  配置文件解析添加共享内存
  -ngx_http_limit_req_zone()                 "limit_req_zone"关键字处理入口，ngx_http_limit_req_module.c
    -ngx_shared_memory_add()                 记录到ngx_cycle->shared_memory链表
      -ngx_list_push()

  创建共享内存
  -main()
    -ngx_init_cycle()
      -for()                                 遍历ngx_cycle_t->shared_memory链表
        -复用老共享内存
        -ngx_shm_alloc()                     利用OS底层的mmap()分配内存
        -ngx_init_zone_pool()                初始化slab管理机制
          -初始化地址信息
          -ngx_shmtx_create()
            -mmap()
          -ngx_slab_init()                   slab入口
        -ngx_shm_zone_t->init()              格式化内存，以适配业务
  #+END_EXAMPLE

** slab机制
nginx的slab管理分两个层级：page页，page页内的slab块儿；其中slab块儿是page
页内存的细粒度管理。参考<智能云 - Openresty.vsdx>。

  #+BEGIN_EXAMPLE
  -ngx_slab_init()                           slab系统初始化入口，ngx_slab.c
  -ngx_slab_alloc()                          slab系统内存分配入口, ngx_slab.c
    -ngx_slab_alloc_locked()
      -ngx_slab_alloc_pages()
  #+END_EXAMPLE

* 初始化插口
  - listen配置解析     :: =ngx_http_core_listen():~/src/http/ngx_http_core_module.c=
  - 建立监听插口结构   :: =ngx_http_optimize_servers():~/src/http/ngx_http.c=
  - 建立监听链路       :: =ngx_open_listening_sockets():~/src/core/ngx_connection.c=
  - 根据listen配置设置链路属性  :: =ngx_configure_listening_sockets():~/src/core/ngx_connection.c=

  #+BEGIN_EXAMPLE
  调用流程
  -main()                                          ~/src/core/nginx.c
     -ngx_init_cycle()                             ~/src/core/ngx_cycle.c
        -ngx_conf_parse()
           -ngx_http_block()                       ngx_http_module模块儿解析
              -ngx_http_core_server()              server{}解析
                 -ngx_http_core_listen()           listen配置解析
                 -...
                 -ngx_http_add_listen()            解析结果挂接入配置系统
              -ngx_http_optimize_servers()         创建监听插口结构
        -...
        -ngx_open_listening_sockets()              创建链路
        -ngx_configure_listening_sockets()         配置链路
  #+END_EXAMPLE

* 配置解析
  - 入口函数           :: =ngx_conf_parse():~/src/core/ngx_conf_file.c=
  - http{}入口函数     :: =ngx_http_block():~/src/http/ngx_http.c=
  - server{}入口函数   :: =ngx_http_core_server():~/src/http/ngx_http_core_module.c=
  - location{}入口函数 :: =ngx_http_core_location():~/src/http/ngx_http_core_module.c=
  - 配置合并处理入口   :: =ngx_http_merge_servers():~/src/http/ngx_http.c=

#+CAPTION: 四级指针视图
[[file:ngx_http_module-http{}.png]]

#+CAPTION: SERVER上下文视图
[[file:ngx_http_core_module-server{}.png]]

#+CAPTION: LOCATION上下文视图
[[file:ngx_http_core_module-location{}.png]]

#+CAPTION: location优化后视图
[[file:ngx_http_core_module-loc_conf-optimization.png]]

[[http://blog.csdn.net/xiaofei0859/article/details/51848897][参考网址]]

* 模块儿初始化流程
#+BEGIN_EXAMPLE
--main()                        入口，~/src/core/nginx.c
    --ngx_preinit_modules()         初始化ngx_modules[].index及模块儿名
    --ngx_init_cycle()              配置解析
        --ngx_cycle_modules()           创建模块儿的配置环境, 并初始化
        --ngx_modules[]->ctx->create_conf()  
                                        NGX_CORE_MODULE类型模块创建配置环境,ngx_cycle->conf_ctx[]
        --ngx_conf_parse()
            --ngx_conf_handler()            解析配置主入口，ngx_conf_file.c
                                            其中涉及模块儿配置信息结构的内存分配等
                -- 查找ngx_cycle_t->modules[]->commands[]
                   获取对应的处理命令
                -- 调用命令->set()
        --ngx_modules[]->ctx->init_conf()    
                                        未配置的项采用默认值
        --ngx_init_modules()            模块儿启动前的特殊准备，主要针对集成的第三方
            --ngx_cycle_t->modules[]->init_module()
    ---------------单进程模式---------------
    --ngx_single_process_cycle()
        --ngx_modules[]->init_process() 模块儿进程级初始化(所有)
    -----------master+worker模式------------
    --ngx_master_process_cycle()
        --ngx_start_worker_processes()
            --ngx_worker_process_cycle()              fork()后，worker进程的执行入口点
                --ngx_worker_process_init()
                    --ngx_modules[]->init_process()   ~/src/os/unix/ngx_process_cycle.c
#+END_EXAMPLE

* worker进程
*入口函数* =ngx_worker_process_cycle():~/src/os/unix/ngx_process_cycle.c=

* 高速IO模型
nginx是以事件驱动的高速模型，无事件时一直阻塞在epoll_wait()--worker进程/
sigsuspend()--master进程等系统调用上。nginx进程主要关注两类事件，I/O事件
和定时器事件。
  - 初始化入口           : =ngx_event_process_init():~/src/event/ngx_event.c=
  - worker主循环处理入口 : =ngx_process_events_and_timers():~/src/event/ngx_event.c=
  - EPOLL事件处理入口    : =ngx_epoll_process_events():~/src/event/modules/ngx_epoll_module.c=
  - ACCEPT事件处理入口   : =ngx_event_accept():~/src/event/ngx_event_accept.c=
  

  #+BEGIN_EXAMPLE
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_events_block()                      events{}解析，ngx_event.c
     -ngx_init_modules()
        -ngx_event_module_init()
  -ngx_master_process_cycle()
     -ngx_start_worker_processes()
        -ngx_spawn_process()
           -fork()
           -ngx_worker_process_cycle()           worker进程执行入口
              -ngx_worker_process_init()
                 -ngx_event_process_init()
                    -初始化事件队列
                    -ngx_epoll_init()
                       -epoll_create()
                       -创建epoll事件结构数组
                       -设置底层IO句柄ngx_os_io
                       -设置数据处理句柄ngx_epoll_module_ctx.actions
                    -读、写信息链表
                    -建立监听链路结构与请求结构读对应关系
                    -设置ACCEPT事件处理句柄ngx_event_accept/ngx_event_recvmsg
              -for(;;)                          worker处理循环
                 -ngx_process_events_and_timers()
                    -ngx_trylock_accept_mutex() 添加待监控链路到EPOLL系统
                    -ngx_process_events()       处理
                    -ngx_event_process_posted()
    #+END_EXAMPLE

* 变量
变量指nginx配置中使用的可变符号，以$开头；nginx推出变量机制，是为方便用户根据
实时环境定制复杂的控制逻辑。
  - 仅支持字符串类型的变量 
  - 赋值为自动赋值、惰性赋值
  - 内部变量为预定义的
  - 也支持外部变量(自定义变量)

  #+BEGIN_EXAMPLE
  -ngx_init_cycle()
    -ngx_conf_parse()
      -ngx_http_block()                  解析http{}入口
        -ngx_http_module_t->preconfiguration() 
                                         在http{}解析前调用, 将各个模块儿支持
                                           的变量加入ngx_http_core_main_conf_t
                                           ->variables_keys, 此处为内
                                           部变量，如ngx_http_core_variables[]
        -ngx_conf_parse()                递归调用解析http内容，配置文件中的外
          -ngx_http_rewrite_set()          部变量，也加入->variables_keys，如
            -ngx_http_add_variable()       ngx_http_rewrite_module模块儿的"set"
            -ngx_http_get_variable_index() 指令，同时也加入->variables表
        -...
        -ngx_http_variables_init_vars()  配置文件引用的变量的合法性检测
  ----------------------------------------------------
  -ngx_http_init_connection()            ~/src/http/ngx_http_request.c
    -ngx_http_wait_request_handler()     接收请求
      -ngx_http_create_request()         创建请求信息结构ngx_http_request_t
        -ngx_pcalloc()                   分配内存ngx_http_request_t->variables，
                                           代表可能的变量值，对应变量名
                                           ngx_http_core_main_conf_t->variables
                                           因此它们的索引一致
      -ngx_http_process_request_line()
        -ngx_http_process_request_headers()
          -ngx_http_process_request()
            -ngx_http_handler()
              -ngx_http_core_run_phases()
                -ngx_http_rewrite_handler()    重写阶段入口函数，设置需要的变量值
            -ngx_http_run_posted_requests()
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  对应指令"set $arg_a 30;"的脚本流程
  -ngx_http_rewrite_set()                "set"指令处理入口，~/src/http/modules/ngx_http_rewrite_module.c
    -ngx_http_rewrite_value()            构建脚本引擎
  
  脚本执行流程, NGX_HTTP_REWRITE_PHASE阶段
  -ngx_http_rewrite_handler()            脚本引擎处理句柄入口，ngx_http_rewrite_module.c
  #+END_EXAMPLE

* HTTP请求处理
以下函数列表顺序，代表了HTTP请求的处理顺序
  - 处理入口             :: =ngx_http_init_connection():~/src/http/ngx_http_request.c=
  - 接收请求头           :: =ngx_http_wait_request_handler()=
  - 处理请求行           :: =ngx_http_process_request_line()=
  - 处理请求头           :: =ngx_http_process_request_headers()=
  - HTTP请求处理入口     :: =ngx_http_process_request()=
  - phase handler入口    :: =ngx_http_core_run_phases()=
  - 当前处理完毕后，触发子请求   :: =ngx_http_run_posted_requests()=
  - 处理完毕后清理入口   :: =ngx_http_finalize_request()=

** 结束请求
#+BEGIN_EXAMPLE
-ngx_http_finalize_request()                 ~/src/http/ngx_http_request.c
  -ngx_http_finalize_connection()
    -ngx_http_close_request()
      -ngx_http_free_request()               释放请求相关内存
      -ngx_http_close_connection()
        -ngx_close_connection()              关闭底层连接
#+END_EXAMPLE

** keepalive机制
#+BEGIN_EXAMPLE
-ngx_http_process_request()                  解析完毕开始处理请求，~/src/http/ngx_http_request.c
  -ngx_http_handler()                        各阶段处理，~/src/http/ngx_http_core_module.c
    -ngx_http_request_t->keepalive           =0/1, 设置是否保活
    -ngx_http_core_run_phases()
...
-ngx_http_finalize_request()                 结束请求, ~/src/http/ngx_http_request.c
  -ngx_http_finalize_connection()
    -ngx_http_set_keepalive()
      -ngx_http_free_request()               释放当前请求内存
      -设置数据接收处理句柄                  ngx_event_t->handler=ngx_http_keepalive_handler()
      -ngx_reusable_connection()             设置链路重用，加入可重用队列
      -ngx_add_timer()                       设置包括超时定时器
#+END_EXAMPLE

** TODO 子请求
** TODO pipe
** TODO 延迟关闭

* 模块儿分类
虽然nginx模块儿很多，功能各不相同，但根据其功能性质，大体上可分为4类：
  - handlers       :: 协同完成客户端请求、产生响应数据
  - filters        :: 过滤handler产生的数据
  - upstream       :: 利用此模块儿，可充当七层反向代理的角色
  - load-balance   :: 配合upstream，实现后端真实服务器的负载均衡
  - stream         :: 实现四层反向代理

** TODO 模块儿初始化顺序
   
* handle phase
  - 阶段名              :: 11阶段， =ngx_http_phases:~/src/http/ngx_http_core_module.h=
  - 注册                :: =各模块儿ngx_module_t->ctx->postconfiguration()=
  - 优化排序            :: =ngx_http_init_phase_handlers():~/src/http/ngx_http.c=
  - 执行入口            :: =ngx_http_core_run_phases():~/src/http/ngx_http_core_module.c=

  #+BEGIN_EXAMPLE
  此四阶段不能挂接回调函数
    NGX_HTTP_FIND_CONFIG_PHASE
    NGX_HTTP_POST_REWRITE_PHASE
    NGX_HTTP_POST_ACCESS_PHASE
    NGX_HTTP_TRY_FILES_PHASE

  流程
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_http_block()
           -递归解析
           -ngx_module_t->ctx->postconfiguration()
           -ngx_http_init_phase_handlers()
     -...
  -for(;;)                                     worker处理循环
     -ngx_process_events_and_timers()
     -ngx_event_process_posted()
        -ngx_http_init_connection()
          -ngx_http_wait_request_handler()
            -ngx_http_process_request_line()
              -ngx_http_process_request_headers()
                -ngx_http_process_request()
                  -ngx_http_handler()
                    -ngx_http_core_run_phases()
                  -ngx_http_run_posted_requests()
  #+END_EXAMPLE
* filter模块儿
对于http请求处理handler产生的响应内容，在发送给客户端前，需过滤处理；这
些过滤模块儿对于增强功能、提升性能非常必要。

由于http数据包括头部和内容两部分，因此过滤模块儿对应的处理函数也一般有
两个，分别对应header和body；这些函数组成两条过滤链，分别由指针变量
=ngx_http_top_header_filter= 和 =ngx_http_top_body_filter= 索引。

** 过滤链的形成机理
  #+BEGIN_EXAMPLE
  定义链表首元素指针                        ~/src/http/ngx_http.c
  ngx_http_output_header_filter_pt  ngx_http_top_header_filter;
  ngx_http_output_body_filter_pt    ngx_http_top_body_filter;
  ngx_http_request_body_filter_pt   ngx_http_top_request_body_filter;
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  注册链表的起始模块儿，注册完成后链表的尾模块儿
  ngx_http_write_filter_module
  ngx_http_header_filter_module
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  各filter模块儿定义局部指针
  static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
  static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;
 
  利用以下串联关系，组成单链表；先注册的最终将靠近链表尾端，后执行
  ngx_http_next_header_filter = ngx_http_top_header_filter;
  ngx_http_top_header_filter = xxx_filter;
  #+END_EXAMPLE

** 被调用流程
  #+BEGIN_EXAMPLE
  发送头部、内容一般在内容处理模块儿被调用
  -ngx_http_send_header()
    -ngx_http_top_header_filter()        首部过滤链入口
  -ngx_http_output_filter()
    -ngx_http_top_body_filter()          尾部过滤链入口
  #+END_EXAMPLE

* 七层代理
此模块儿与具体的协议无关，除HTTP外，还支持包括FASTCGI、SCGI、MEMCACHED等；
典型应用是反向代理。
 - ngx_http_upstream_module
   : ~/src/http/ngx_http_upstream.c
   : 对应upstream{}配置指令
 - ngx_http_proxy_module
   : ~/src/http/modules/ngx_http_proxy_module.c
   : 对应location{proxy_pass}配置，提供请求到upstream的代理通道
 - ngx_http_upstream_ip_hash_module
   : ~/src/http/modules/ngx_http_upstream_ip_hash_module.c
   : 对应upstream{ip_hash;}配置，提供IP HASH类型的LB算法
 - ngx_http_upstream_keepalive_module
   : ~/src/http/modules/ngx_http_upstream_keepalive_module.c
   : 对应upstream{keepalive}配置，提供upstream链路保活机制

** 解析流程
upstream{}配置解析
#+BEGIN_EXAMPLE
-main()
  -ngx_init_cycle()
    -ngx_conf_parse()                         配置文件解析入口，~/src/core/ngx_conf_file.c
      -ngx_conf_read_token()                  读取关键字
      -ngx_conf_handler()                     处理关键字
        -ngx_conf_t->cycle->modules[i]->commands->set()
        -->ngx_http_block()                   http{}处理入口, ~/src/http/ngx_http.c
          -->ngx_http_core_server()             server{}处理入口，~/src/http/ngx_http_core_module.c
          -->ngx_http_core_location()           location{}处理入口，~/src/http/ngx_http_core_module.c
          -->ngx_http_upstream()                upstream{}处理入口，~/src/http/ngx_http_upstream.c
            -ngx_http_upstream_server()           server处理入口，~/src/http/ngx_http_upstream.c
            -ngx_http_upstream_ip_hash()          ip_hash处理入口，~/src/http/modules/ngx_http_upstream_ip_hash_module.c
          -ngx_http_upstream_module->->ctx->init_main_conf()
          -->ngx_http_upstream_init_main_conf() 初始化upstream主配置，~/src/http/ngx_http_upstream.c
            -ngx_http_upstream_srv_conf_t->peer.init_upstream()
            -->ngx_http_upstream_init_ip_hash()   ip_hash算法初始化
            -装载upstream支持的http属性头 ngx_http_upstream_headers_in[]
#+END_EXAMPLE

proxy_pass配置解析
#+BEGIN_EXAMPLE
-ngx_http_core_location()                     location{}处理入口，~/src/http/ngx_http_core_module.c
  -ngx_http_proxy_pass()                      proxy_pass指令，~/src/http/modules/ngx_http_proxy_module.c
    -ngx_http_core_loc_conf_t->handler          设置处理句柄ngx_http_proxy_handler()
    -ngx_http_upstream_add()                    查找对应的upstream
#+END_EXAMPLE

** HTTP请求处理流程
收到客户端请求报文的处理流程
#+BEGIN_EXAMPLE
-ngx_http_wait_request_handler()
  -ngx_http_process_request_headers()
    -ngx_http_core_run_phases()
      -ngx_http_core_find_config_phase()   NGX_HTTP_FIND_CONFIG_PHASE阶段->checker
        -赋值ngx_http_request_t->content_handler()
      -ngx_http_core_content_phase()       NGX_HTTP_CONTENT_PHASE阶段->checker, ~/src/http/ngx_http_core_module.c
        -ngx_http_proxy_handler()            proxy_pass处理入口, ~/src/http/modules/ngx_http_proxy_module.c
        -ngx_http_finalize_request()
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-ngx_http_proxy_handler()            proxy_pass处理入口, ~/src/http/modules/ngx_http_proxy_module.c
  -设置upstream请求处理句柄
    -ngx_http_upstream_t->create_request = ngx_http_proxy_create_request()
    -ngx_http_upstream_t->process_header = ngx_http_proxy_process_status_line()
    -ngx_http_upstream_t->finalize_request = ngx_http_proxy_finalize_request()
  -ngx_http_read_client_request_body()
    -ngx_http_upstream_init()
      -ngx_http_upstream_init_request()
        -ngx_http_upstream_t->create_request()       创建请求
        -ngx_http_upstream_srv_conf_t->peer.init()   初始化LB环境
        -->ngx_http_upstream_init_ip_hash_peer()
        -ngx_http_upstream_connect()                 ~/src/http/ngx_http_upstream.c
          -ngx_event_connect_peer()                  创建连接
          -设置处理句柄
            -ngx_connection_t->write->handler = ngx_http_upstream_handler()
            -ngx_connection_t->read->handler = ngx_http_upstream_handler()
            -ngx_http_upstream_t->write_event_handler = ngx_http_upstream_send_request_handler()
            -ngx_http_upstream_t->read_event_handler = ngx_http_upstream_process_header()
          -ngx_http_upstream_ssl_init_connection()   SSL环境下的发送函数
          -ngx_http_upstream_send_request()          普通环境的发送函数
            -ngx_http_upstream_send_request_body()
#+END_EXAMPLE

收到真实服务器的回应报文的处理流程
#+BEGIN_EXAMPLE
-ngx_http_upstream_handler()                  ~/src/http/ngx_http_upstream.c
  -ngx_http_upstream_t->read_event_handler()
  -->ngx_http_upstream_process_header()
    -ngx_connection_t->recv()                    接收
    -ngx_http_upstream_t->process_header()
    -->ngx_http_proxy_process_status_line()      解析应答行
      -ngx_http_proxy_process_header()           解析HTTP属性头
    -ngx_http_upstream_process_headers()         处理HTTP属性头
    -ngx_http_upstream_send_response()           向客户端发送服务器应答
      -ngx_http_send_header()
      -ngx_http_upstream_process_non_buffered_downstream()
      -ngx_http_upstream_finalize_request()
  -ngx_http_run_posted_requests()             处理后续请求
#+END_EXAMPLE

** upstream链路缓存
利用模块儿初始化顺序，替换原LB层操控指针，以在其上加入cache层，以保证主
流程代码不变。
#+BEGIN_EXAMPLE
-ngx_http_upstream_keepalive()            upstream{keepalive}配置指令解析函数，~/src/http/modules/ngx_http_upstream_keepalive_module.c
  -保存并替换LB环境初始化函数             ngx_http_upstream_srv_conf_t->peer.init_upstream = ngx_http_upstream_init_keepalive()

-ngx_http_upstream_init_keepalive()
  -保存并替换LB数据初始化函数             ngx_http_upstream_srv_conf_t->peer.init = ngx_http_upstream_init_keepalive_peer()

-ngx_http_upstream_init_keepalive_peer()
  -保存并替换服务器选择/释放函数          ngx_http_request_t->upstream->peer.get = ngx_http_upstream_get_keepalive_peer()
                                          ngx_http_request_t->upstream->peer.free = ngx_http_upstream_free_keepalive_peer()

-ngx_http_upstream_get_keepalive_peer()   获取upstream服务器连接
  -原LB查找算法，查找后端主机
  -搜索cache，查看是否有此主机的链接
  -有则利用
  -无则返回重新建立链接

-ngx_http_upstream_free_keepalive_peer()  释放upstream服务器连接
  -存储到缓存(超过设定数则替换)
  -调用原LB释放算法
#+END_EXAMPLE

* 四层代理
 - ngx_stream_module
   : ~/src/stream/ngx_stream.c
 - ngx_stream_core_module
   : ~/src/stream/ngx_stream_core_module.c
 - ngx_stream_proxy_module
   : ~/src/stream/ngx_stream_proxy_module.c
 - ngx_stream_upstream_module
   : ~/src/stream/ngx_stream_upstream_module.c
 - ngx_stream_upstream_hash_module
   : ~/src/stream/ngx_stream_upstream_hash_module.c

** 解析流程
** 处理流程

* TODO load-balance模块儿
可用称为辅助模块儿，主要为upstream模块儿服务，决定如何从多台后端服务器中
选择一台合适的服务器来处理请求。

* DONE ngx_http_limit_conn_module
  CLOSED: [2016-11-23 Wed 18:29]
nginx提供了基于KEY限制链接的模块儿，比如限制来自某个IP的链接总数；内部通过
"简单链接++计数(较限速模块儿简单许多)，当请求结束后--"实现。

  #+BEGIN_EXAMPLE
  执行阶段
      NGX_HTTP_PREACCESS_PHASE

  流程
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_http_block()
           -递归解析
             -ngx_http_limit_conn_zone()            处理配置指令limit_conn_zone
             -ngx_http_limit_conn()                 处理limit_conn
             -ngx_conf_set_enum_slot()              处理limit_conn_log_level
             -ngx_conf_set_num_slot()               处理limit_conn_status
           -ngx_module_t->ctx->postconfiguration()
             -ngx_http_limit_conn_init()            注册处理句柄ngx_http_limit_conn_handler()

     -...
  -for(;;)                                          worker处理循环
     -ngx_process_events_and_timers()
     -ngx_event_process_posted()
       -...
       -ngx_http_core_run_phases()
         -ngx_http_limit_conn_handler()             限速处理, ~/src/http/modules/ngx_http_limit_conn_module.c
  
  #+END_EXAMPLE

** 典型配置
  #+BEGIN_EXAMPLE
  http {
    limit_conn_zone $binary_remote_addr zone=one:10m;
                                           #定义限链接区域，one，空间10M大小
    ...
    server {
        ...
        location /search/ {
            limit_conn zone=one 5;         #基于源IP的限链接，并存的链接不能大于5
        }
  #+END_EXAMPLE

* DONE ngx_http_req_limit_module
  CLOSED: [2016-11-21 Mon 17:47]
本模块儿用于限制特定key的访问速率，比如限制来自某个IP的处理速率；内部通过
漏桶("leaky bucket")算法实现。

限速策略必须逐个过，此模块儿存在如下限制：
  1. 不能针对KEY的不同值，限定不同的访问频率(如，不同IP不同限速)
  2. 不能实时动态更改, 只能通过修改配置RELOAD NGINX来生效 */


数据结构关系图，参考<智能云 - Openresty.vsdx>

  #+BEGIN_EXAMPLE
  执行阶段
      NGX_HTTP_PREACCESS_PHASE

  流程
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_http_block()
           -递归解析
             -ngx_http_limit_req_zone()             处理配置指令limit_req_zone
             -ngx_http_limit_req()                  处理limit_req
             -ngx_conf_set_enum_slot()              处理limit_req_log_level
             -ngx_conf_set_num_slot()               处理limit_req_status
           -ngx_module_t->ctx->postconfiguration()
             -ngx_http_limit_req_init()             注册处理句柄，ngx_http_limit_req_handler()

     -...
  -for(;;)                                          worker处理循环
     -ngx_process_events_and_timers()
     -ngx_event_process_posted()
       -...
       -ngx_http_core_run_phases()
         -ngx_http_limit_req_handler()              限速处理, ~/src/http/modules/ngx_http_limit_req_module.c
  
  #+END_EXAMPLE

** 典型配置
  #+BEGIN_EXAMPLE
  http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
                                                    #定义限速区域，one，空间10M大小，速率1秒1请求，key值为源IP
    ...
    server {
        ...
        location /search/ {
            limit_req zone=one burst=5;             #基于源IP的限速，1秒1个请求，突发量小于5
        }
  #+END_EXAMPLE

** 漏桶原理
当主机接口向网络中传送数据包时，可采取漏桶算法，使得接口输出数据流的速率恒定。
  - 队列接收到准备转发的数据包
  - 队列被调度，得到转发机会
  - 根据数据包到达漏桶的速率与漏桶的输出速率关系，确定数据包是否被转发
     : 如果到达速率≤输出速率，则漏桶不起作用
     : 如果到达速率>输出速率，则需考虑漏桶是否能承担这个瞬间的流量
     :   1) 若数据包到达的速率-漏桶流出的速率≤配置的漏桶突发速率，则数据包可
     :      被不延时的送出
     :   2) 若数据包到达的速率-漏桶流出的速率>配置的漏桶突发速率，则多余的数
     :      据包被存储到漏桶中暂存在漏桶中的数据包在不超过漏桶容量的情况下延
     :      时发出
     :   3) 若数据包到达的速率-漏桶流出的速率>配置的漏桶突发速率，且数据包的
     :      数量已经超过漏桶的容量，则这些数据包将被丢弃

* DONE ngx_http_stub_status_module
  CLOSED: [2016-11-25 Fri 14:19]
此模块儿默认不编译，因此需添加配置参数，如下：
  #+BEGIN_EXAMPLE
  ./configure --with-http_stub_status_module ...(other params)
  #+END_EXAMPLE
此模块儿可通过配置指令"stub_status"在某个"location{}"环境注册静态
页面，以方便返回统计信息，配置如下：
  #+BEGIN_EXAMPLE
  location /basic_status {
    stub_status;
  }
  
  可通过curl此地址查看统计信息。
  #+END_EXAMPLE


执行到配置了“stub_status”的location后，靠此模块儿注册的回调句柄生
成页面内容，并会送。
  #+BEGIN_EXAMPLE
  -ngx_http_core_run_phases()             阶段执行函数入口，~/src/http/ngx_http_core_module.c
    -ngx_http_core_find_config_phase()    NGX_HTTP_FIND_CONFIG_PHASE句柄
      -ngx_http_update_location_config()  设置ngx_http_request_t->content_handler，页面生成句柄
    -ngx_http_core_content_phase()        NGX_HTTP_CONTENT_PHASE句柄
      -ngx_http_stub_status_handler()     利用ngx_http_request_t->content_handler，生成页面
                                             ~/src/http/modules/ngx_http_stub_status_module.c
  #+END_EXAMPLE


那这些信息是在哪里统计的呢？
  #+BEGIN_EXAMPLE
  原子变量定义，~/src/event/ngx_event.c

  ngx_atomic_t   ngx_stat_accepted0;      单进程模式，利用此变量
  ngx_atomic_t  *ngx_stat_accepted = &ngx_stat_accepted0;
  ...
  #+END_EXAMPLE
  #+BEGIN_EXAMPLE
  原子变量内存地址，主从进程模式，利用共享内存

  -main()                                入口，~/src/core/nginx.c
      -ngx_init_cycle()
          -ngx_conf_parse()              配置解析
          -ngx_init_modules()            模块儿启动前的特殊准备，主要针对集成的第三方
            -ngx_cycle_t->modules[]->init_module()
            -ngx_event_module_init()     ngx_event_core_module模块儿，~/src/event/ngx_event.c
              -ngx_shmtx_create()        分配共享内存，用于统计的变量，如ngx_stat_xxx
  #+END_EXAMPLE


这些信息在哪里统计呢？在 =ngx_event_core_module= 模块儿，如 =ngx_event_accept()= 等

* DONE 脚本引擎
  CLOSED: [2016-11-24 Thu 17:36]
编译字符串为可执行脚本
  #+BEGIN_EXAMPLE
  -ngx_http_compile_complex_value()                编译入口，~/src/http/ngx_http_script.c
    -ngx_http_script_compile()
      -ngx_http_script_add_capture_code()          生成捕捉变量脚本
      -ngx_http_script_add_var_code()              生成普通变量脚本
      -ngx_http_script_add_args_code()             生成参数脚本
      -ngx_http_script_add_copy_code()             生成普通字符串(非变量、非参数)脚本
      -ngx_http_script_done()
  #+END_EXAMPLE

执行脚本
  #+BEGIN_EXAMPLE
  -ngx_http_complex_value()                        获取变量值，ngx_http_script.c
    -ngx_http_script_flush_complex_value()         清空不可缓存的变量值
    -执行脚本组->lengths，获取所有变量长度
    -分配内存以盛放结果
    -执行脚本组->values，获取变量的值
  #+END_EXAMPLE

* 变量 =limit_rate/limit_rate_after=
NGINX提供了限制服务器回应速率的手段；通过使用 =ngx_add_timer= 函数实现对
write event的控制，进而实现速度上限的控制。

 =limit_rate= 限制了应答传输速率，单位 =bytes/s= ；0表示不限制； 此
限制是基于链接的，并且可以通过变量$limit_rate动态设置，因此可以根据
特定场景，设置不同的值，非常灵活、方便。

=limit_rate_after= 如其名字，当应答报文的大小超过了设定值后，才开始
限速。

  #+BEGIN_EXAMPLE
  nginx典型配置如下：

  location /flv/ {
    ...
    limit_rate_after 500k;
    limit_rate       50k;
  }
  #+END_EXAMPLE

** 入口
限制入口位于模块儿ngx_http_write_filter_module的处理函数；此模块儿
实现发送过滤，位于整个过滤链 =ngx_http_top_body_filter= 的尾端。

  #+BEGIN_EXAMPLE
  ngx_http_write_filter(): ~/src/http/ngx_http_write_filter_module.c
  #+END_EXAMPLE

* SSL
 - ngx_openssl_module
   : ~/src/event/ngx_event_openssl.c
   : 对接底层openssl库
 - ngx_http_ssl_module
   : ~/src/http/modules/ngx_http_ssl_module.c
   : 对接用户配置指令，提供SSL服务器的能力
 - ngx_http_proxy_module
   : ~/src/http/modules/ngx_http_proxy_module.c
   : 对接upsream, 提供proxy_pass的SSL配置
 - ngx_stream_ssl_module
   : ~/src/stream/ngx_stream_ssl_module.c
   : 对接downstream，实现四层SSL代理
 - ngx_stream_proxy_module
   : ~/stream/ngx_stream_proxy_module.c
   : 对接upstream，实现四层SSL代理

** 七层DownStream
#+BEGIN_EXAMPLE
做为SSL服务器的处理流程
-main()                            ~/src/core/nginx.c
  -ngx_ssl_init()                  初始化SSL环境，~/src/event/ngx_event_openssl.c
  -ngx_init_cycle()                解析配置
    -ngx_http_ssl_merge_srv_conf()   解析配置后，合并结果, ~/src/http/modules/ngx_http_ssl_module.c
      -ngx_ssl_create()              创建SSL环境
      -ngx_ssl_certificates()        加载证书及私钥
      -ngx_ssl_ciphers()             加载指定套件
      -ngx_ssl_client_certificate()  加载客户端认证
      -ngx_ssl_trusted_certificate()
      -ngx_ssl_crl()                 加载CRL表
      -ngx_ssl_dhparam()
      -ngx_ssl_ecdh_curve()
      -ngx_ssl_session_cache()       会话恢复
      -ngx_ssl_session_ticket_keys()
      -ngx_ssl_stapling()
  -ngx_master_process_cycle()      启动worker进程，进入事件循环
    -ngx_process_events_and_timers() EPOLL处理入口
      -ngx_event_process_posted()    处理accept事件
        -ngx_event_accept()
          -accept()
          -ngx_http_init_connection()
            -ngx_event_t->handler      设定接收数据的处理句柄=ngx_http_ssl_handshake()
      -ngx_event_process_posted()    处理收发报文事件
        -ngx_http_ssl_handshake()      SSL接收数据并处理, ~/src/http/ngx_http_request.c
          -ngx_ssl_create_connection()
          -ngx_ssl_handshake()              握手成功后，设置底层收发处理函数为ngx_ssl_recv/ngx_ssl_write()(~/src/event/ngx_event_openssl.c)
          -ngx_http_ssl_handshake_handler() 握手完成后，设置SSL解密后的处理入口为ngx_http_wait_request_handler()
#+END_EXAMPLE

** 七层upstream
#+BEGIN_EXAMPLE
做为SSL客户端的处理流程
-main()
  -ngx_ssl_init()
  -ngx_init_cycle()                解析配置
    -ngx_http_proxy_merge_loc_conf() 配置解析后，合并结果，~/src/http/modules/ngx_http_proxy_module.c
      -ngx_http_proxy_set_ssl()      创建SSL环境
  -ngx_master_process_cycle()      启动worker进程，进入事件循环
    -ngx_http_proxy_handler()        upstream处理入口，~/src/http/modules/ngx_http_proxy_module.c
      -ngx_http_read_client_request_body()
        -ngx_http_do_read_client_request_body()
        -ngx_http_upstream_init()
          -ngx_http_upstream_init_request()
            -ngx_http_upstream_t->create_request()       创建请求
            -ngx_http_upstream_srv_conf_t->peer.init()   初始化LB环境, 获取链接的服务器
            -ngx_http_upstream_connect()                 ~/src/http/ngx_http_upstream.c
              -ngx_event_connect_peer()                  创建连接
                -socket()
                -connect()
              -ngx_http_upstream_ssl_init_connection()   SSL环境下的发送函数
                -ngx_ssl_create_connection()
                -ngx_ssl_handshake()                     握手成功后，设置底层收发处理函数为ngx_ssl_recv/ngx_ssl_write()
                -ngx_http_upstream_ssl_handshake()
                  -设置ngx_connection_t->write/read->handler  =ngx_http_upstream_handler()
                  -ngx_http_upstream_send_request()      发送请求
#+END_EXAMPLE

** 四层Downstream
ab

** 四层upstream
ab

