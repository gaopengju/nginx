#+TITLE: NGINX代码导读
#+AUTHOR: sqlfocus


* 入口
*文件* main():~/src/core/nginx.c

* 信号处理
*函数入口* =ngx_signal_process():~/src/os/unix/ngx_process.c=

对应命令行参数-s

* 时间缓存
*函数* ~ngx_time_init()~ : =~/src/core/ngx_times.c=

nginx中的时间以秒为粒度，被缓存起来，并形成丰富的字符串格式；此设计使得
少更新多读取的时间操作尤其高效。

缓存时间设定了定量的槽位，构成缓存循环队列；以免某些请求的处理时间大于s
的粒度，造成紊乱。

* DONE 定时器管理
  CLOSED: [2016-10-26 Wed 14:03]
事件超时意味着等待的事件没有在指定的时间内到达，nginx有必要对这些可能发生
超时的事件进行统一管理，并在事件发生超时时做出相应的处理，比如回收资源、
返回错误等。

超时管理需要解决两个问题，第一，超时事件对象如何组织，nginx采用红黑树；第
儿，超时检测。

nginx采用两种方式检测超时，第一，定时检测机制，通过设定定时器，每隔一段时
间对红黑树扫瞄一次；第二，计算最快发生的事件需要等待的时间，在系统调用函数
epoll_wait()中，设定此超时时限，以便尽快儿检测。

定时检测机制通过配置指令"timer_resolution 100ms;"指定。

  #+BEGIN_EXAMPLE
  -ngx_worker_process_cycle()         worker进程入口
    -ngx_worker_process_init()        worker进程初始化
      -ngx_module_t->init_process()
      =ngx_event_process_init()      
        -ngx_event_timer_init()       红黑树初始化入口，ngx_event_timer.c
    -for(;;)
      -ngx_process_events_and_timers()
        -ngx_event_find_timer()       计算最近事件的超时时间间隔
        -ngx_event_expire_timers()    处理超时事件

  添加超时事件
  -ngx_add_timer()                    入口，ngx_event.h
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  定时检测机制
     1) 通过指令"timer_resolution 100ms;"设置后，在初始化时会启动系统定时器，
        以定期向进程发送信号；
     2) 定时器信号SIGALRM被捕获后，设置全局变量，从而触发epoll_wait()系统调
        用返回，并更新内部时钟；
     3) worker进程处理请求间歇，检测到内部时钟变更，则触发超时事件树扫瞄
  从以上描述可知，虽然信号保证了触发粒度，但worker进程只在请求处理返回后才能
  处理超时事件，因此无法保证及时处理。考虑到nginx的请求处理速度，这不是什么
  问题。

  从流程中也可看出，采用方式二可能带来更高精度。

  -ngx_worker_process_cycle()
    -ngx_worker_process_init()
      -ngx_module_t->init_process()
      =ngx_event_process_init()  
        -ngx_event_timer_init()
        -setitimer()                  设定定时器，以定时触发ngx_timer_signal_handler()
                                      此函数设置ngx_event_timer_alarm变量
    -for(;;)
      -ngx_process_events_and_timers()
        -根据超时事件类型，设置不同标志
          -定时扫瞄不设置标识
          -非定时扫瞄设置标识NGX_UPDATE_TIME
        -ngx_process_events()
        =ngx_epoll_process_events()
          -epoll_wait()
          -ngx_time_update()          ngx_event_timer_alarm=1 或 设置了NGX_UPDATE_TIME标识
        -计算运行时间
          -只有运行了ngx_time_update()后，才有值
        -ngx_event_expire_timers()    处理超时事件，运行时间不等于0时调用
  #+END_EXAMPLE

* 插口继承
*函数* =ngx_add_inherited_sockets()= :~/src/core/nginx.c

启动nginx时，可通过环境变量NGINX继承已有的socket插口

* 进程间通信
一般情况下，nginx以多进程模型运作，这些进程间通信有多种方式，如共享内存、匿名
管道等。

** 匿名管道
采用socketpair()创建的匿名管道，对于Linux下具有亲缘关系的进程之间的通信是不错
的解决方案。

进程信息及管道句柄等记录在全局数据结构，ngx_processes[]，此结构在进程被fork出
的过程中初始化；并在进程退出后更新。

  #+BEGIN_EXAMPLE
  ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];     /* ngx_process.c */

  typedef struct {
    ngx_pid_t           pid;              /* 进程ID */
    int                 status;           /* waitpid()的返回值 */
    ngx_socket_t        channel[2];       /* 进程间通信的管道
                                             worker[1] -- master[0]
                                             worker[0] -- other worker[1] */

    ngx_spawn_proc_pt   proc;             /* 进程入口函数 */
    void               *data;             /* 进程私有信息; 对于worker为启动index，即0~ngx_core_conf_t->worker_processes */
    char               *name;             /* 进程名 */
    
    unsigned            respawn:1;        /* 进程退出后是否自动重启 */
    unsigned            just_spawn:1;
    unsigned            detached:1;       /* 脱离跟踪，不和主进程及其他进程建通信管道 */
    unsigned            exiting:1;
    unsigned            exited:1;         /* 0/1, 是否已经退出 */
  } ngx_process_t;
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  -main()
    -ngx_master_process_cycle()
      1-ngx_start_worker_processes()
        -ngx_spawn_process()
          -socketpair()
          -fork()
          -----------------------------子进程----------------------------
          -ngx_worker_process_cycle()            worker进程入口
            -ngx_worker_process_init()
              -ngx_add_channel_event()           监听其他进程的管道描述符，处
                                                 理句柄ngx_channel_handler()
            -for(;;)
          -----------------------------父进程----------------------------
          -记录PID/管道描述符等到ngx_processes[]
        -ngx_pass_open_channel()                 利用消息通知其他进程，有新进程加入
          -ngx_write_channel()
            -sendmsg()                           利用了进程间描述符传递
      1-for(;;)                                  信号处理
        -退出相关信号设计管道信息变更            上半阶段处理ngx_signal_handler()
                                                 后半阶段处理在此循环中
  #+END_EXAMPLE

** 共享内存
共享内存是Linux下进程间通信的最有效方式之一，nginx提供了统一接口以方便模块儿
使用共享内存。

  #+BEGIN_EXAMPLE
  配置文件示例
  http {
     #为限速模块儿所用，ngx_http_limit_req_module
     limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
     ...
  }

  配置文件解析添加共享内存
  -ngx_http_limit_req_zone()                 "limit_req_zone"关键字处理入口，ngx_http_limit_req_module.c
    -ngx_shared_memory_add()                 记录到ngx_cycle->shared_memory链表
      -ngx_list_push()

  创建共享内存
  -main()
    -ngx_init_cycle()
      -for()                                 遍历ngx_cycle_t->shared_memory链表
        -复用老共享内存
        -ngx_shm_alloc()                     利用OS底层的mmap()分配内存
        -ngx_init_zone_pool()                初始化slab管理机制
          -初始化地址信息
          -ngx_shmtx_create()
            -mmap()
          -ngx_slab_init()                   slab入口
        -ngx_shm_zone_t->init()              格式化内存，以适配业务
  #+END_EXAMPLE

** slab机制
nginx的slab管理分两个层级：page页，page页内的slab块儿；其中slab块儿是page
页内存的细粒度管理。参考<智能云 - Openresty.vsdx>。

  #+BEGIN_EXAMPLE
  -ngx_slab_init()                           slab系统初始化入口，ngx_slab.c
  -ngx_slab_alloc()                          slab系统内存分配入口, ngx_slab.c
    -ngx_slab_alloc_locked()
      -ngx_slab_alloc_pages()
  #+END_EXAMPLE

* 初始化插口
  - listen配置解析     :: =ngx_http_core_listen():~/src/http/ngx_http_core_module.c=
  - 建立监听插口结构   :: =ngx_http_optimize_servers():~/src/http/ngx_http.c=
  - 建立监听链路       :: =ngx_open_listening_sockets():~/src/core/ngx_connection.c=
  - 根据listen配置设置链路属性  :: =ngx_configure_listening_sockets():~/src/core/ngx_connection.c=

  #+BEGIN_EXAMPLE
  调用流程
  -main()                                          ~/src/core/nginx.c
     -ngx_init_cycle()                             ~/src/core/ngx_cycle.c
        -ngx_conf_parse()
           -ngx_http_block()                       ngx_http_module模块儿解析
              -ngx_http_core_server()              server{}解析
                 -ngx_http_core_listen()           listen配置解析
                 -...
                 -ngx_http_add_listen()            解析结果挂接入配置系统
              -ngx_http_optimize_servers()         创建监听插口结构
        -...
        -ngx_open_listening_sockets()              创建链路
        -ngx_configure_listening_sockets()         配置链路
  #+END_EXAMPLE

* 配置解析
  - 入口函数           :: =ngx_conf_parse():~/src/core/ngx_conf_file.c=
  - http{}入口函数     :: =ngx_http_block():~/src/http/ngx_http.c=
  - server{}入口函数   :: =ngx_http_core_server():~/src/http/ngx_http_core_module.c=
  - location{}入口函数 :: =ngx_http_core_location():~/src/http/ngx_http_core_module.c=
  - 配置合并处理入口   :: =ngx_http_merge_servers():~/src/http/ngx_http.c=

#+CAPTION: 四级指针视图
[[file:ngx_http_module-http{}.png]]

#+CAPTION: SERVER上下文视图
[[file:ngx_http_core_module-server{}.png]]

#+CAPTION: LOCATION上下文视图
[[file:ngx_http_core_module-location{}.png]]

#+CAPTION: location优化后视图
[[file:ngx_http_core_module-loc_conf-optimization.png]]

[[http://blog.csdn.net/xiaofei0859/article/details/51848897][参考网址]]

* 模块儿初始化流程
#+BEGIN_EXAMPLE
--main()                        入口，~/src/core/nginx.c
    --ngx_preinit_modules()         初始化ngx_modules[].index及模块儿名
    --ngx_init_cycle()              配置解析
        --ngx_cycle_modules()           创建模块儿的配置环境, 并初始化
        --ngx_modules[]->ctx->create_conf()  
                                        NGX_CORE_MODULE类型模块创建配置环境,ngx_cycle->conf_ctx[]
        --ngx_conf_parse()
            --ngx_conf_handler()            解析配置主入口，ngx_conf_file.c
                                            其中涉及模块儿配置信息结构的内存分配等
                -- 查找ngx_cycle_t->modules[]->commands[]
                   获取对应的处理命令
                -- 调用命令->set()
        --ngx_modules[]->ctx->init_conf()    
                                        未配置的项采用默认值
        --ngx_init_modules()            模块儿启动前的特殊准备，主要针对集成的第三方
            --ngx_cycle_t->modules[]->init_module()
    ---------------单进程模式---------------
    --ngx_single_process_cycle()
        --ngx_modules[]->init_process() 模块儿进程级初始化(所有)
    -----------master+worker模式------------
    --ngx_master_process_cycle()
        --ngx_start_worker_processes()
            --ngx_worker_process_cycle()              fork()后，worker进程的执行入口点
                --ngx_worker_process_init()
                    --ngx_modules[]->init_process()   ~/src/os/unix/ngx_process_cycle.c
#+END_EXAMPLE

* worker进程
*入口函数* =ngx_worker_process_cycle():~/src/os/unix/ngx_process_cycle.c=

* 高速IO模型
nginx是以事件驱动的高速模型，无事件时一直阻塞在epoll_wait()--worker进程/
sigsuspend()--master进程等系统调用上。nginx进程主要关注两类事件，I/O事件
和定时器事件。
  - 初始化入口           : =ngx_event_process_init():~/src/event/ngx_event.c=
  - worker主循环处理入口 : =ngx_process_events_and_timers():~/src/event/ngx_event.c=
  - EPOLL事件处理入口    : =ngx_epoll_process_events():~/src/event/modules/ngx_epoll_module.c=
  - ACCEPT事件处理入口   : =ngx_event_accept():~/src/event/ngx_event_accept.c=
  

  #+BEGIN_EXAMPLE
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_events_block()                      events{}解析，ngx_event.c
     -ngx_init_modules()
        -ngx_event_module_init()
  -ngx_master_process_cycle()
     -ngx_start_worker_processes()
        -ngx_spawn_process()
           -fork()
           -ngx_worker_process_cycle()           worker进程执行入口
              -ngx_worker_process_init()
                 -ngx_event_process_init()
                    -初始化事件队列
                    -ngx_epoll_init()
                       -epoll_create()
                       -创建epoll事件结构数组
                       -设置底层IO句柄ngx_os_io
                       -设置数据处理句柄ngx_epoll_module_ctx.actions
                    -读、写信息链表
                    -建立监听链路结构与请求结构读对应关系
                    -设置ACCEPT事件处理句柄ngx_event_accept/ngx_event_recvmsg
              -for(;;)                          worker处理循环
                 -ngx_process_events_and_timers()
                    -ngx_trylock_accept_mutex() 添加待监控链路到EPOLL系统
                    -ngx_process_events()       处理
                    -ngx_event_process_posted()
    #+END_EXAMPLE

* 变量
变量指nginx配置中使用的可变符号，以$开头；nginx推出变量机制，是为方便用户根据
实时环境定制复杂的控制逻辑。
  - 仅支持字符串类型的变量 
  - 赋值为自动赋值、惰性赋值
  - 内部变量为预定义的
  - 也支持外部变量(自定义变量)

  #+BEGIN_EXAMPLE
  -ngx_init_cycle()
    -ngx_conf_parse()
      -ngx_http_block()                  解析http{}入口
        -ngx_http_module_t->preconfiguration() 
                                         在http{}解析前调用, 将各个模块儿支持
                                           的变量加入ngx_http_core_main_conf_t
                                           ->variables_keys, 此处为内
                                           部变量，如ngx_http_core_variables[]
        -ngx_conf_parse()                递归调用解析http内容，配置文件中的外
          -ngx_http_rewrite_set()          部变量，也加入->variables_keys，如
            -ngx_http_add_variable()       ngx_http_rewrite_module模块儿的"set"
            -ngx_http_get_variable_index() 指令，同时也加入->variables表
        -...
        -ngx_http_variables_init_vars()  合法性检测
  ----------------------------------------------------
  -ngx_http_init_connection()            ~/src/http/ngx_http_request.c
    -ngx_http_wait_request_handler()     接收请求
      -ngx_http_create_request()         创建请求信息结构ngx_http_request_t
        -ngx_pcalloc()                   分配内存ngx_http_request_t->variables，
                                           代表可能的变量值，对应变量名
                                           ngx_http_core_main_conf_t->variables
                                           因此它们的索引一致
      -ngx_http_process_request_line()
        -ngx_http_process_request_headers()
          -ngx_http_process_request()
            -ngx_http_handler()
              -ngx_http_core_run_phases()
                -ngx_http_rewrite_handler()    重写阶段入口函数，设置需要的变量值
            -ngx_http_run_posted_requests()
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  对应指令"set $arg_a 30;"的脚本流程
  -ngx_http_rewrite_set()                "set"指令处理入口，~/src/http/modules/ngx_http_rewrite_module.c
    -ngx_http_rewrite_value()            构建脚本引擎
  
  脚本执行流程, NGX_HTTP_REWRITE_PHASE阶段
  -ngx_http_rewrite_handler()            脚本引擎处理句柄入口，ngx_http_rewrite_module.c
  #+END_EXAMPLE

* HTTP请求处理
以下函数列表顺序，代表了HTTP请求的处理顺序
  - 处理入口             :: =ngx_http_init_connection():~/src/http/ngx_http_request.c=
  - 接收请求头           :: =ngx_http_wait_request_handler()=
  - 处理请求行           :: =ngx_http_process_request_line()=
  - 处理请求头           :: =ngx_http_process_request_headers()=
  - HTTP请求处理入口     :: =ngx_http_process_request()=
  - phase handler入口    :: =ngx_http_core_run_phases()=
  - 当前处理完毕后，触发子请求   :: =ngx_http_run_posted_requests()=

* 模块儿分类
虽然nginx模块儿很多，功能各不相同，但根据其功能性质，大体上可分为4类：
  - handlers       :: 协同完成客户端请求、产生响应数据
  - filters        :: 过滤handler产生的数据
  - upstream       :: 利用此模块儿，可充当反向代理的角色
  - load-balance   :: 配合upstream，实现后端真实服务器的负载均衡

* handle phase
  - 阶段名              :: 11阶段， =ngx_http_phases:~/src/http/ngx_http_core_module.h=
  - 注册                :: =各模块儿ngx_module_t->ctx->postconfiguration()=
  - 优化排序            :: =ngx_http_init_phase_handlers():~/src/http/ngx_http.c=
  - 执行入口            :: =ngx_http_core_run_phases():~/src/http/ngx_http_core_module.c=

  #+BEGIN_EXAMPLE
  此四阶段不能挂接回调函数
    NGX_HTTP_FIND_CONFIG_PHASE
    NGX_HTTP_POST_REWRITE_PHASE
    NGX_HTTP_POST_ACCESS_PHASE
    NGX_HTTP_TRY_FILES_PHASE

  流程
  -ngx_init_cycle()
     -ngx_conf_parse()
        -ngx_http_block()
           -递归解析
           -ngx_module_t->ctx->postconfiguration()
           -ngx_http_init_phase_handlers()
     -...
  -for(;;)                                     worker处理循环
     -ngx_process_events_and_timers()
     -ngx_event_process_posted()
        -ngx_http_init_connection()
          -ngx_http_wait_request_handler()
            -ngx_http_process_request_line()
              -ngx_http_process_request_headers()
                -ngx_http_process_request()
                  -ngx_http_handler()
                    -ngx_http_core_run_phases()
                  -ngx_http_run_posted_requests()
  #+END_EXAMPLE
* filter模块儿
对于http请求处理handler产生的响应内容，在发送给客户端前，需过滤处理；这
些过滤模块儿对于增强功能、提升性能非常必要。

由于http数据包括头部和内容两部分，因此过滤模块儿对应的处理函数也一般有
两个，分别对应header和body；这些函数组成两条过滤链，分别由指针变量
=ngx_http_top_header_filter= 和 =ngx_http_top_body_filter= 索引。

** 过滤链的形成机理
  #+BEGIN_EXAMPLE
  定义链表首元素指针                        ~/src/http/ngx_http.c
  ngx_http_output_header_filter_pt  ngx_http_top_header_filter;
  ngx_http_output_body_filter_pt    ngx_http_top_body_filter;
  ngx_http_request_body_filter_pt   ngx_http_top_request_body_filter;
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  注册链表的起始模块儿，注册完成后链表的尾模块儿
  ngx_http_write_filter_module
  ngx_http_header_filter_module
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  各filter模块儿定义局部指针
  static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
  static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;
 
  利用以下串联关系，组成单链表；先注册的最终将靠近链表尾端，后执行
  ngx_http_next_header_filter = ngx_http_top_header_filter;
  ngx_http_top_header_filter = xxx_filter;
  #+END_EXAMPLE

** 被调用流程
  #+BEGIN_EXAMPLE
  发送头部、内容一般在内容处理模块儿被调用
  -ngx_http_send_header()
    -ngx_http_top_header_filter()        首部过滤链入口
  -ngx_http_output_filter()
    -ngx_http_top_body_filter()          尾部过滤链入口
  #+END_EXAMPLE

* TODO upstream模块儿
此模块儿与具体的协议无关，除HTTP外，还支持包括FASTCGI、SCGI、MEMCACHED等；
典型应用是反向代理。

* TODO load-balance模块儿
可用称为辅助模块儿，主要为upstream模块儿服务，决定如何从多台后端服务器中
选择一台合适的服务器来处理请求。

* TODO ngx_http_req_limit_module
请求限速模块儿

* TODO ngx_http_proxy_module
HTTP的反向代理模块儿

  #+BEGIN_EXAMPLE
  ngx_http_upstream()  解析入口
  ngx_http_upstream_server()  server解析
  ngx_http_proxy_pass()  proxy_pass解析入口
  ngx_http_proxy_handler()  内容处理阶段入口
  #+END_EXAMPLE


