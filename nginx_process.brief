本文档摘录master + worker模式的nginx进程的启动生成过程, 备忘


1. ngx_single_process_cycle
2. ngx_master_process_cycle
3. ngx_start_worker_processes
10.全局数据结构
    ---ngx_processes[]



1. ngx_single_process_cycle()
    @file: ~/src/os/unix/ngx_process_cycle.c
    @role: 单进程模式的处理入口

    --ngx_set_environment()     保存环境变量
        --ngx_get_conf()            获取ngx_core_module的配置信息
        --ngx_array_push()          添加元素, ngx_core_conf_t->env[]
        --设置ngx_core_conf_t->environment
    --for()                     遍历ngx_modules[]
        --->init_process()          执行进程初始化函数
    --for()                     <Bang!!!>主循环
        --ngx_process_events_and_timers()
                                    处理ACCEPT + 定时器等的入口; 类似
                                        master+worker模式，
                                        参考<nginx_worker.brief>
        --if()                      如果ngx_terminate || ngx_quit置位
            --ngx_modules[]->exit_process()
            --ngx_master_process_exit()
        --if()                      如果ngx_reconfigure置位
            --ngx_init_cycle()          refer <nginx_cycle.brief>
            --赋值ngx_cycle
        --if()                      如果ngx_reopen置位
            --ngx_reopen_files()

2. ngx_master_process_cycle()
    @file: ~/src/os/unix/ngx_process_cycle.c
    @role: master+worker模式的处理入口
    @note: 主进程通过fork方式启动业务进程, 剩余的事情就是等待信号,
            包括用户、worker进程、内核等发送的

    --sigprocmask()             屏蔽支持的信号, 如SIGALRM/SIGINT等
    --ngx_setproctitle()        设置程序title, master process
    --ngx_start_worker_processes()
                                <Bang!!!>启动工作进程, NGX_PROCESS_RESPAWN
    --ngx_start_cache_manager_processes()
                                启动缓存管理进程, refer <_cache.brief>
    --for()                     <Bang!!!>主循环, 只处理信号
        --sigsuspend()              阻塞等待信号
        --ngx_time_update()         更新缓存时间
        --                          处理ngx_terminate/ngx_quit
            --ngx_master_process_exit()
            --ngx_signal_worker_processes()
        --                          处理ngx_reconfigure
            --ngx_start_worker_processes()
            --ngx_start_cache_manager_processes()
        --                          处理ngx_restart
            --ngx_start_worker_processes()
            --ngx_start_cache_manager_processes()
        --                          处理ngx_reopen
            --ngx_reopen_files()
            --ngx_signal_worker_processes()
        --                          处理ngx_change_binary
            --ngx_exec_new_binary()
        --                          处理ngx_noaccept
            --ngx_signal_worker_processes()

3. ngx_start_worker_processes()
    @file: ~/src/os/unix/ngx_process_cycle.c
    @role: 启动工作进程

    --ngx_spawn_process()       启动worker进程, 类型NGX_PROCESS_RESPAWN
        --查找ngx_processes[]       找寻可用结构, 赋值ngx_process_slot
                                        代表此数组的索引
        --socketpair()              创建通信管道, 赋值[1]给ngx_channel
        --ngx_nonblocking()
        --fcntl()
        --fork()                    创建子进程
        -------------子进程-------------
        --ngx_getpid()              获取子进程ID
        --ngx_worker_process_cycle()注意此函数不返回, <nginx_worker.brief>
        -------------父进程-------------
        --记录信息到ngx_processes[]
            --包括.pid/.proc/.data/.name等
        --递增ngx_last_process++
    --ngx_pass_open_channel()   通知其他worker进程，新加入了worker进程; 
        --ngx_write_channel()       初始化各自进程的ngx_processes[].channel[0],
                                    以便worker之间能够利用管道通信
            --sendmsg()

10.全局数据结构
    10.1 ngx_processes[]
    @file: ~/src/os/unix/ngx_process.c
    @role: 记录各进程的状态, 同时通过channel[]管道使得各个进程可以互通;
            另外, 在各进程中都有一份, 分别维护自身状态

    ngx_process_t  ngx_processes[NGX_MAX_PROCESSES];

    typedef struct {
        ngx_pid_t           pid;            worker进程PID
        int                 status;
        ngx_socket_t        channel[2];     master+worker进程通信管道pipe;
                                                0在master端或其他的worker端，
                                                1在当前的worker端
        ngx_spawn_proc_pt   proc;           worker主循环函数
        void               *data;           worker的启动序号0~N
        char               *name;           worker的title名

        unsigned            respawn:1;      是否重新启动？
        unsigned            just_spawn:1;
        unsigned            detached:1;     脱离master控制？
        unsigned            exiting:1;      退出状态
        unsigned            exited:1;
    } ngx_process_t;









