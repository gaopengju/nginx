本文档摘录worker进程的处理流程, 以期能够串联底层接口操作、上层应用逻辑
处理, 备忘


1. ngx_worker_process_cycle
2. ngx_channel_handler
3. ngx_process_events_and_timers
10.全局数据结构


1. ngx_worker_process_cycle()
    @file: ~/src/os/unix/ngx_process_cycle.c
    @role: worker进程的执行入口点

    --赋值ngx_process           = NGX_PROCESS_WORKER, 工作进程
                                    变量参考<nginx.brief>
    --ngx_worker_process_init() 进程初始化
        --ngx_set_environment()
        --setpriority()             设置优先级
        --setrlimit()               设置资源限制
        --setgid/setuid()           降低权限
        --ngx_get_cpu_affinity()    设置CPU亲昵性; 根据worker_cpu_affinity 
        --ngx_setaffinity()             设置worker进程运行的cpu核心
        --chdir()                   迁移工作路径
        --sigprocmask()             设置信号屏蔽
        --srandom()                 初始化随机数种子
        --ngx_modules[]->init_process()
                                    各模块儿进程初始化
        --close()                   关闭无用的ngx_processes[].channel[1]
                                        关闭ngx_processes[本进程].channel[0]
        --ngx_add_channel_event()   监听对应的ngx_processes[].channel[1]
                                        处理函数ngx_channel_handler()
    --ngx_setproctitle()        设置进程title为"worker process"
    --for()                     <Bang!!!>主循环
        --                          处理ngx_exiting
            --ngx_event_cancel_timers()
            --ngx_worker_process_exit()
        --ngx_process_events_and_timers()
                                    处理ACCEPT和时钟事件等
        --                          处理ngx_terminate
            --ngx_worker_process_exit()
        --                          处理ngx_quit
            --ngx_setproctitle()
            --ngx_close_listening_sockets()
        --                          处理ngx_reopen
            --ngx_reopen_files()

2. ngx_channel_handler()
    @file: ~/src/os/unix/ngx_process_cycle.c
    @role: worker进程监控自身管道ngx_processes[].channel[1]
            的事件处理函数

    --ngx_read_channel()        读管道
    --                          处理NGX_USE_EVENTPORT_EVENT, 添加监控
                                事件, refer <nginx_mod_epoll.brief>
        --ngx_add_event()
            --ngx_event_actions.add()
            -->ngx_epoll_add_event()
    --                          处理NGX_CMD_OPEN_CHANNEL, 此处用到了文件
                                    描述符传递; 初始化worker与worker之
                                    间的通信管道pipe
        --初始化ngx_processes[].pid/channel[0]
    --                          处理NGX_CMD_CLOSE_CHANNEL
        --close()                   关闭对应的ngx_processes[].channel[0]
    --                          处理NGX_CMD_QUIT
        --设置ngx_quit              = 1
    --                          处理NGX_CMD_TERMINATE
        --设置nngx_terminate        = 1
    --                          处理NGX_CMD_REOPEN
        --设置ngx_reopen            = 1

3. ngx_process_events_and_timers()
    @file: ~/src/event/ngx_event.c
    @role: 处理ACCEPT事件及定时器事件, 衔接底层插口事件和上层
            HTTP业务处理的函数
    @note:
        1) 通过全局变量ngx_use_accept_mutex决定是否采用accetp并发锁;
            在ngx_event_core_module->ngx_event_process_init()中初始
            化, 如果多个worker进程则 = 1, 否则 = 0
        2) 事件处理分优先级, ACCEPT需要加锁操作; 其余的读、写事件则
            不需要加锁, 解锁后操作; 以最大限度提高并行度

    --ngx_event_find_timer()    计算将要到期定时器事件到当前时间的时间间隔
    --                          设置NGX_UPDATE_TIME标志, 触发更新缓存时间
    --                          <Bang!!!>获取ACCEPT锁, 多worker进程争抢; 
                                    避免多个worker之间处理accept的"惊群",
                                    及负载不均匀
        --如果ngx_accept_disabled有值, 则不主动获取
            锁, 此值在ngx_event_accept()函数设置, 表
            示当前进程的繁忙程度; 如果繁忙, 则不再
            接受请求
        --ngx_trylock_accept_mutex()
                                    获取锁成功后, 设置NGX_POST_EVENTS标识,
            --ngx_enable_accept_events()    并添加插口的读监控事件
                --ngx_add_event()           refer <nginx_mod_epoll.brief>
                    --ngx_event_actions.add()
                    -->ngx_epoll_add_event()
            --赋值ngx_accept_mutex_held     = 1
            --赋值ngx_accept_events         = 0
    --ngx_process_events()      处理事件, refer <nginx_mod_epoll.brief>
                                    加入对应的队列, 
                                    ngx_posted_accept_events或
                                    ngx_posted_events, 然后迅速返回
        --ngx_event_actions.process_events()
        -->ngx_epoll_process_events()
    --ngx_event_process_posted()处理队列ngx_posted_accept_events, ACCEPT
                                    事件, refer <nginx_event.brief>
    --ngx_shmtx_unlock()        释放锁
    --ngx_event_expire_timers() 处理定时器事件
    --ngx_event_process_posted()处理队列ngx_posted_events












